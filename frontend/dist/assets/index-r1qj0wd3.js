import{z as fe,i as Pe,h as L,p as ye,a as be,g as we,b as Ee,c as Ie,e as M,d as m,f as E,B as $,w as ve,s as xe,u as pe,t as u,j as W,v as B,k as Y,l as Le,m as Ae,n as w,M as _,o as oe,q as ee,S as Fe,r as Se,x as h,y as ze,R as S,A as Ge,C as X,D as ae,E as Ce,F as ce,T as he}from"./index-BD8GSUFS.js";import{Chain as Te,Common as j}from"./index-C3QarFsj.js";class p{constructor(e){if(e.length!==20)throw new Error("Invalid address length");this.bytes=e}static zero(){return new p(fe(20))}static fromString(e){if(!Pe(e))throw new Error(`Invalid address input=${e}`);return new p(L(e))}static fromPublicKey(e){if(!(e instanceof Uint8Array))throw new Error("Public key should be Uint8Array");const t=ye(e);return new p(t)}static fromPrivateKey(e){if(!(e instanceof Uint8Array))throw new Error("Private key should be Uint8Array");const t=be(e);return new p(t)}static generate(e,t){if(typeof t!="bigint")throw new Error("Expected nonce to be a bigint");return new p(we(e.bytes,Ee(t)))}static generate2(e,t,s){if(!(t instanceof Uint8Array))throw new Error("Expected salt to be a Uint8Array");if(!(s instanceof Uint8Array))throw new Error("Expected initCode to be a Uint8Array");return new p(Ie(e.bytes,t,s))}equals(e){return M(this.bytes,e.bytes)}isZero(){return this.equals(p.zero())}isPrecompileOrSystemAddress(){const e=m(this.bytes),t=$,s=BigInt("0xffff");return e>=t&&e<=s}toString(){return E(this.bytes)}toBytes(){return new Uint8Array(this.bytes)}}const ke=ve(xe),Ne=32,te=4096,J=32*te,Me=2,Be=J*Me-1,_e=Ne*te;function Oe(r,e){const t=new Uint8Array(e*J).fill(0);return t.set(r),t[r.byteLength]=128,t}function $e(r){const e=new Uint8Array(_e);for(let t=0;t<te;t++){const s=new Uint8Array(32);s.set(r.subarray(t*31,(t+1)*31),0),e.set(s,t*32)}return e}const Ue=r=>{const e=pe(r),t=e.byteLength;if(t===0)throw Error("invalid blob data");if(t>Be)throw Error("blob data is too large");const s=Math.ceil(t/J),i=Oe(e,s),n=[];for(let o=0;o<s;o++){const a=i.subarray(o*J,(o+1)*J),c=$e(a);n.push(c)}return n},Je=(r,e)=>{const t=[];for(const s of e)t.push(r.blobToKzgCommitment(s));return t},Ve=(r,e,t)=>e.map((i,n)=>r.computeBlobKzgProof(i,t[n])),ge=(r,e)=>{const t=new Uint8Array(32);return t.set([e],0),t.set(ke(r).subarray(1),1),t},He=r=>{const e=[];for(const t of r)e.push(ge(t,1));return e},Ke=async(r,e)=>{const t=JSON.stringify({method:e.method,params:e.params,jsonrpc:"2.0",id:1}),s=await fetch(r,{headers:{"content-type":"application/json"},method:"POST",body:t});if(!s.ok)throw new Error(`JSONRpcError: ${JSON.stringify({method:e.method,status:s.status,message:await s.text().catch(()=>"Could not parse error message likely because of a network error")},null,2)}`);return(await s.json()).result},Re=r=>{if(typeof r=="string")return r;if(typeof r=="object"&&r._getConnection!==void 0)return r._getConnection().url;throw new Error("Must provide valid provider URL or Web3Provider")};var A;(function(r){r[r.EIP155ReplayProtection=155]="EIP155ReplayProtection",r[r.EIP1559FeeMarket=1559]="EIP1559FeeMarket",r[r.EIP2718TypedTransaction=2718]="EIP2718TypedTransaction",r[r.EIP2930AccessLists=2930]="EIP2930AccessLists",r[r.EIP7702EOACode=7702]="EIP7702EOACode"})(A||(A={}));function De(r){if(r.length===0)return!0;const e=r[0];return!!Array.isArray(e)}function je(r){return!De(r)}function Xe(r){if(r.length===0)return!0;const e=r[0];return!!Array.isArray(e)}function Ze(r){return!Xe(r)}var y;(function(r){r[r.Legacy=0]="Legacy",r[r.AccessListEIP2930=1]="AccessListEIP2930",r[r.FeeMarketEIP1559=2]="FeeMarketEIP1559",r[r.BlobEIP4844=3]="BlobEIP4844",r[r.EOACodeEIP7702=4]="EOACodeEIP7702"})(y||(y={}));function qe(r){return Number(m(u(r.type)))===y.Legacy}function We(r){return Number(m(u(r.type)))===y.AccessListEIP2930}function Ye(r){return Number(m(u(r.type)))===y.FeeMarketEIP1559}function Qe(r){return Number(m(u(r.type)))===y.BlobEIP4844}function et(r){return Number(m(u(r.type)))===y.EOACodeEIP7702}function tt(r,e){const t=r.param("vm","maxInitCodeSize");if(t&&BigInt(e)>t)throw new Error(`the initcode size of this transaction is too large: it is ${e} while the max is ${r.param("vm","maxInitCodeSize")}`)}class I{static getAccessListData(e){let t,s;if(je(e)){t=e;const i=[];for(let n=0;n<e.length;n++){const o=e[n],a=L(o.address),c=[];for(let d=0;d<o.storageKeys.length;d++)c.push(L(o.storageKeys[d]));i.push([a,c])}s=i}else{s=e??[];const i=[];for(let n=0;n<s.length;n++){const o=s[n],a=E(o[0]),c=[];for(let l=0;l<o[1].length;l++)c.push(E(o[1][l]));const d={address:a,storageKeys:c};i.push(d)}t=i}return{AccessListJSON:t,accessList:s}}static verifyAccessList(e){for(let t=0;t<e.length;t++){const s=e[t],i=s[0],n=s[1];if(s[2]!==void 0)throw new Error("Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.");if(i.length!==20)throw new Error("Invalid EIP-2930 transaction: address length should be 20 bytes");for(let o=0;o<n.length;o++)if(n[o].length!==32)throw new Error("Invalid EIP-2930 transaction: storage slot length should be 32 bytes")}}static getAccessListJSON(e){const t=[];for(let s=0;s<e.length;s++){const i=e[s],n={address:E(W(i[0],20)),storageKeys:[]},o=i[1];for(let a=0;a<o.length;a++){const c=o[a];n.storageKeys.push(E(W(c,32)))}t.push(n)}return t}static getDataFeeEIP2930(e,t){const s=t.param("gasPrices","accessListStorageKeyCost"),i=t.param("gasPrices","accessListAddressCost");let n=0;for(let a=0;a<e.length;a++){const d=e[a][1];n+=d.length}return e.length*Number(i)+n*Number(s)}}class de{static getAuthorizationListData(e){let t,s;if(Ze(e)){t=e;const i=[],n=["chainId","address","nonce","yParity","r","s"];for(let o=0;o<e.length;o++){const a=e[o];for(const P of n)if(a[P]===void 0)throw new Error(`EIP-7702 authorization list invalid: ${P} is not defined`);const c=L(a.chainId),d=L(a.address),l=[];for(let P=0;P<a.nonce.length;P++)l.push(L(a.nonce[P]));const f=L(a.yParity),b=L(a.r),g=L(a.s);i.push([c,d,l,f,b,g])}s=i}else{s=e??[];const i=[];for(let n=0;n<s.length;n++){const o=s[n],a=E(o[0]),c=E(o[1]),d=o[2],l=[];for(let v=0;v<d.length;v++)l.push(E(d[v]));const f=E(o[3]),b=E(o[4]),g=E(o[5]),P={chainId:a,address:c,nonce:l,yParity:f,r:b,s:g};i.push(P)}t=i}return{AuthorizationListJSON:t,authorizationList:s}}static verifyAuthorizationList(e){for(let t=0;t<e.length;t++){const s=e[t],i=s[1],n=s[2],o=s[3],a=s[4],c=s[5];if(B({yParity:o,r:a,s:c}),i.length!==20)throw new Error("Invalid EIP-7702 transaction: address length should be 20 bytes");if(n.length>1)throw new Error("Invalid EIP-7702 transaction: nonce list should consist of at most 1 item");n.length===1&&B({nonce:n[0]})}}static getDataFeeEIP7702(e,t){const s=t.param("gasPrices","perAuthBaseCost");return e.length*Number(s)}}function O(r){return L(`0x${r.toString(16).padStart(2,"0")}`)}class x{constructor(e,t){this.cache={hash:void 0,dataFee:void 0,senderPubKey:void 0},this.activeCapabilities=[],this.DEFAULT_CHAIN=Te.Mainnet;const{nonce:s,gasLimit:i,to:n,value:o,data:a,v:c,r:d,s:l,type:f}=e;this._type=Number(m(u(f))),this.txOptions=t;const b=u(n===""?"0x":n),g=u(c),P=u(d),v=u(l);this.nonce=m(u(s)),this.gasLimit=m(u(i)),this.to=b.length>0?new p(b):void 0,this.value=m(u(o)),this.data=u(a===""?"0x":a),this.v=g.length>0?m(g):void 0,this.r=P.length>0?m(P):void 0,this.s=v.length>0?m(v):void 0,this._validateCannotExceedMaxInteger({value:this.value,r:this.r,s:this.s}),this._validateCannotExceedMaxInteger({gasLimit:this.gasLimit},64),this._validateCannotExceedMaxInteger({nonce:this.nonce},64,!0);const R=this.to===void 0||this.to===null,D=t.allowUnlimitedInitCodeSize??!1,U=t.common??this._getCommon();R&&U.isActivatedEIP(3860)&&D===!1&&tt(U,this.data.length)}get type(){return this._type}supports(e){return this.activeCapabilities.includes(e)}getValidationErrors(){const e=[];return this.isSigned()&&!this.verifySignature()&&e.push("Invalid Signature"),this.getBaseFee()>this.gasLimit&&e.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`),e}isValid(){return this.getValidationErrors().length===0}getBaseFee(){const e=this.common.param("gasPrices","tx");let t=this.getDataFee();if(e&&(t+=e),this.common.gteHardfork("homestead")&&this.toCreationAddress()){const s=this.common.param("gasPrices","txCreation");s&&(t+=s)}return t}getDataFee(){const e=this.common.param("gasPrices","txDataZero"),t=this.common.param("gasPrices","txDataNonZero");let s=$;for(let i=0;i<this.data.length;i++)this.data[i]===0?s+=e:s+=t;if((this.to===void 0||this.to===null)&&this.common.isActivatedEIP(3860)){const i=BigInt(Math.ceil(this.data.length/32)),n=this.common.param("gasPrices","initCodeWordCost")*i;s+=n}return s}toCreationAddress(){return this.to===void 0||this.to.bytes.length===0}isSigned(){const{v:e,r:t,s}=this;return!(e===void 0||t===void 0||s===void 0)}verifySignature(){try{const e=this.getSenderPublicKey();return Y(e).length!==0}catch{return!1}}getSenderAddress(){return new p(Le(this.getSenderPublicKey()))}sign(e){var d;if(e.length!==32){const l=this._errorMsg("Private key must be 32 bytes in length.");throw new Error(l)}let t=!1;this.type===y.Legacy&&this.common.gteHardfork("spuriousDragon")&&!this.supports(A.EIP155ReplayProtection)&&(this.activeCapabilities.push(A.EIP155ReplayProtection),t=!0);const s=this.getHashedMessageToSign(),i=((d=this.common.customCrypto)==null?void 0:d.ecsign)??Ae,{v:n,r:o,s:a}=i(s,e),c=this.addSignature(n,o,a,!0);if(t){const l=this.activeCapabilities.indexOf(A.EIP155ReplayProtection);l>-1&&this.activeCapabilities.splice(l,1)}return c}toJSON(){return{type:w(BigInt(this.type)),nonce:w(this.nonce),gasLimit:w(this.gasLimit),to:this.to!==void 0?this.to.toString():void 0,value:w(this.value),data:E(this.data),v:this.v!==void 0?w(this.v):void 0,r:this.r!==void 0?w(this.r):void 0,s:this.s!==void 0?w(this.s):void 0}}_getCommon(e,t){if(t!==void 0){const s=m(u(t));if(e){if(e.chainId()!==s){const i=this._errorMsg(`The chain ID does not match the chain ID of Common. Got: ${s}, expected: ${e.chainId()}`);throw new Error(i)}return e.copy()}else return j.isSupportedChainId(s)?new j({chain:s}):j.custom({name:"custom-chain",networkId:s,chainId:s},{baseChain:this.DEFAULT_CHAIN})}else return(e==null?void 0:e.copy())??new j({chain:this.DEFAULT_CHAIN})}_validateCannotExceedMaxInteger(e,t=256,s=!1){for(const[i,n]of Object.entries(e))switch(t){case 64:if(s){if(n!==void 0&&n>=oe){const o=this._errorMsg(`${i} cannot equal or exceed MAX_UINT64 (2^64-1), given ${n}`);throw new Error(o)}}else if(n!==void 0&&n>oe){const o=this._errorMsg(`${i} cannot exceed MAX_UINT64 (2^64-1), given ${n}`);throw new Error(o)}break;case 256:if(s){if(n!==void 0&&n>=_){const o=this._errorMsg(`${i} cannot equal or exceed MAX_INTEGER (2^256-1), given ${n}`);throw new Error(o)}}else if(n!==void 0&&n>_){const o=this._errorMsg(`${i} cannot exceed MAX_INTEGER (2^256-1), given ${n}`);throw new Error(o)}break;default:{const o=this._errorMsg("unimplemented bits value");throw new Error(o)}}}static _validateNotArray(e){const t=["nonce","gasPrice","gasLimit","to","value","data","v","r","s","type","baseFee","maxFeePerGas","chainId"];for(const[s,i]of Object.entries(e))if(t.includes(s)&&Array.isArray(i))throw new Error(`${s} cannot be an array`)}_getSharedErrorPostfix(){let e="";try{e=this.isSigned()?E(this.hash()):"not available (unsigned)"}catch{e="error"}let t="";try{t=this.isSigned().toString()}catch{e="error"}let s="";try{s=this.common.hardfork()}catch{s="error"}let i=`tx type=${this.type} hash=${e} nonce=${this.nonce} value=${this.value} `;return i+=`signed=${t} hf=${s}`,i}}function se(r,e){const t=r.maxPriorityFeePerGas,s=r.maxFeePerGas-e,n=(t<s?t:s)+e;return r.gasLimit*n+r.value}function re(r,e){if(e===void 0||e>r.maxFeePerGas)throw new Error("Tx cannot pay baseFee");const t=r.maxFeePerGas-e;return r.maxPriorityFeePerGas<t?r.maxPriorityFeePerGas:t}function G(r,e){return`${e} (${r.errorStr()})`}function ie(r,e){if(r.cache.dataFee&&r.cache.dataFee.hardfork===r.common.hardfork())return r.cache.dataFee.value;const t=x.prototype.getDataFee.bind(r)()+(e??0n);return Object.isFrozen(r)&&(r.cache.dataFee={value:t,hardfork:r.common.hardfork()}),t}function V(r){if(!r.isSigned()){const t=G(r,"Cannot call hash method if transaction is not signed");throw new Error(t)}const e=r.common.customCrypto.keccak256??ee;return Object.isFrozen(r)?(r.cache.hash||(r.cache.hash=e(r.serialize())),r.cache.hash):e(r.serialize())}function H(r){const{s:e}=r;if(r.common.gteHardfork("homestead")&&e!==void 0&&e>Fe){const t=G(r,"Invalid Signature: s-values greater than secp256k1n/2 are considered invalid");throw new Error(t)}}function K(r){if(r.cache.senderPubKey!==void 0)return r.cache.senderPubKey;const e=r.getMessageToVerifySignature(),{v:t,r:s,s:i}=r;H(r);try{const o=(r.common.customCrypto.ecrecover??Se)(e,t,h(s),h(i),r.supports(A.EIP155ReplayProtection)?r.common.chainId():void 0);return Object.isFrozen(r)&&(r.cache.senderPubKey=o),o}catch{const o=G(r,"Invalid Signature");throw new Error(o)}}function le(r,e){if(e!==void 0&&e>r)throw new Error("Tx cannot pay baseFee");return e===void 0?r:r-e}function Z(r){return(r.common.customCrypto.keccak256??ee)(r.getMessageToSign())}function z(r,e){return ze(O(r.type),S.encode(e??r.raw()))}function q(r){const{v:e}=r;if(e!==void 0&&e!==$&&e!==Ge){const t=G(r,"The y-parity of the transaction should either be 0 or 1");throw new Error(t)}}function ne(r){return ie(r,BigInt(I.getDataFeeEIP2930(r.accessList,r.common)))}class T extends x{constructor(e,t={}){super({...e,type:y.FeeMarketEIP1559},t);const{chainId:s,accessList:i,maxFeePerGas:n,maxPriorityFeePerGas:o}=e;if(this.common=this._getCommon(t.common,s),this.chainId=this.common.chainId(),!this.common.isActivatedEIP(1559))throw new Error("EIP-1559 not enabled on Common");this.activeCapabilities=this.activeCapabilities.concat([1559,2718,2930]);const a=I.getAccessListData(i??[]);if(this.accessList=a.accessList,this.AccessListJSON=a.AccessListJSON,I.verifyAccessList(this.accessList),this.maxFeePerGas=m(u(n)),this.maxPriorityFeePerGas=m(u(o)),this._validateCannotExceedMaxInteger({maxFeePerGas:this.maxFeePerGas,maxPriorityFeePerGas:this.maxPriorityFeePerGas}),x._validateNotArray(e),this.gasLimit*this.maxFeePerGas>_){const d=this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");throw new Error(d)}if(this.maxFeePerGas<this.maxPriorityFeePerGas){const d=this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");throw new Error(d)}q(this),H(this),((t==null?void 0:t.freeze)??!0)&&Object.freeze(this)}static fromTxData(e,t={}){return new T(e,t)}static fromSerializedTx(e,t={}){if(M(e.subarray(0,1),O(y.FeeMarketEIP1559))===!1)throw new Error(`Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: ${y.FeeMarketEIP1559}, received: ${E(e.subarray(0,1))}`);const s=S.decode(e.subarray(1));if(!Array.isArray(s))throw new Error("Invalid serialized tx input: must be array");return T.fromValuesArray(s,t)}static fromValuesArray(e,t={}){if(e.length!==9&&e.length!==12)throw new Error("Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).");const[s,i,n,o,a,c,d,l,f,b,g,P]=e;return this._validateNotArray({chainId:s,v:b}),B({nonce:i,maxPriorityFeePerGas:n,maxFeePerGas:o,gasLimit:a,value:d,v:b,r:g,s:P}),new T({chainId:m(s),nonce:i,maxPriorityFeePerGas:n,maxFeePerGas:o,gasLimit:a,to:c,value:d,data:l,accessList:f??[],v:b!==void 0?m(b):void 0,r:g,s:P},t)}getDataFee(){return ne(this)}getEffectivePriorityFee(e){return re(this,e)}getUpfrontCost(e=$){return se(this,e)}raw(){return[h(this.chainId),h(this.nonce),h(this.maxPriorityFeePerGas),h(this.maxFeePerGas),h(this.gasLimit),this.to!==void 0?this.to.bytes:new Uint8Array(0),h(this.value),this.data,this.accessList,this.v!==void 0?h(this.v):new Uint8Array(0),this.r!==void 0?h(this.r):new Uint8Array(0),this.s!==void 0?h(this.s):new Uint8Array(0)]}serialize(){return z(this)}getMessageToSign(){return z(this,this.raw().slice(0,9))}getHashedMessageToSign(){return Z(this)}hash(){return V(this)}getMessageToVerifySignature(){return this.getHashedMessageToSign()}getSenderPublicKey(){return K(this)}addSignature(e,t,s,i=!1){t=u(t),s=u(s);const n={...this.txOptions,common:this.common};return T.fromTxData({chainId:this.chainId,nonce:this.nonce,maxPriorityFeePerGas:this.maxPriorityFeePerGas,maxFeePerGas:this.maxFeePerGas,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,accessList:this.accessList,v:i?e-X:e,r:m(t),s:m(s)},n)}toJSON(){const e=I.getAccessListJSON(this.accessList);return{...super.toJSON(),chainId:w(this.chainId),maxPriorityFeePerGas:w(this.maxPriorityFeePerGas),maxFeePerGas:w(this.maxFeePerGas),accessList:e}}errorStr(){let e=this._getSharedErrorPostfix();return e+=` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`,e}_errorMsg(e){return G(this,e)}}class k extends x{constructor(e,t={}){super({...e,type:y.AccessListEIP2930},t);const{chainId:s,accessList:i,gasPrice:n}=e;if(this.common=this._getCommon(t.common,s),this.chainId=this.common.chainId(),!this.common.isActivatedEIP(2930))throw new Error("EIP-2930 not enabled on Common");this.activeCapabilities=this.activeCapabilities.concat([2718,2930]);const o=I.getAccessListData(i??[]);if(this.accessList=o.accessList,this.AccessListJSON=o.AccessListJSON,I.verifyAccessList(this.accessList),this.gasPrice=m(u(n)),this._validateCannotExceedMaxInteger({gasPrice:this.gasPrice}),x._validateNotArray(e),this.gasPrice*this.gasLimit>_){const c=this._errorMsg("gasLimit * gasPrice cannot exceed MAX_INTEGER");throw new Error(c)}q(this),H(this),((t==null?void 0:t.freeze)??!0)&&Object.freeze(this)}static fromTxData(e,t={}){return new k(e,t)}static fromSerializedTx(e,t={}){if(M(e.subarray(0,1),O(y.AccessListEIP2930))===!1)throw new Error(`Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: ${y.AccessListEIP2930}, received: ${E(e.subarray(0,1))}`);const s=S.decode(Uint8Array.from(e.subarray(1)));if(!Array.isArray(s))throw new Error("Invalid serialized tx input: must be array");return k.fromValuesArray(s,t)}static fromValuesArray(e,t={}){if(e.length!==8&&e.length!==11)throw new Error("Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).");const[s,i,n,o,a,c,d,l,f,b,g]=e;this._validateNotArray({chainId:s,v:f}),B({nonce:i,gasPrice:n,gasLimit:o,value:c,v:f,r:b,s:g});const P=[];return new k({chainId:m(s),nonce:i,gasPrice:n,gasLimit:o,to:a,value:c,data:d,accessList:l??P,v:f!==void 0?m(f):void 0,r:b,s:g},t)}getEffectivePriorityFee(e){return le(this.gasPrice,e)}getDataFee(){return ne(this)}getUpfrontCost(){return this.gasLimit*this.gasPrice+this.value}raw(){return[h(this.chainId),h(this.nonce),h(this.gasPrice),h(this.gasLimit),this.to!==void 0?this.to.bytes:new Uint8Array(0),h(this.value),this.data,this.accessList,this.v!==void 0?h(this.v):new Uint8Array(0),this.r!==void 0?h(this.r):new Uint8Array(0),this.s!==void 0?h(this.s):new Uint8Array(0)]}serialize(){return z(this)}getMessageToSign(){return z(this,this.raw().slice(0,8))}getHashedMessageToSign(){return Z(this)}hash(){return V(this)}getMessageToVerifySignature(){return this.getHashedMessageToSign()}getSenderPublicKey(){return K(this)}addSignature(e,t,s,i=!1){t=u(t),s=u(s);const n={...this.txOptions,common:this.common};return k.fromTxData({chainId:this.chainId,nonce:this.nonce,gasPrice:this.gasPrice,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,accessList:this.accessList,v:i?e-X:e,r:m(t),s:m(s)},n)}toJSON(){const e=I.getAccessListJSON(this.accessList);return{...super.toJSON(),chainId:w(this.chainId),gasPrice:w(this.gasPrice),accessList:e}}errorStr(){var t;let e=this._getSharedErrorPostfix();return e+=` gasPrice=${this.gasPrice} accessListCount=${((t=this.accessList)==null?void 0:t.length)??0}`,e}_errorMsg(e){return G(this,e)}}const ue=6,st=(r,e,t,s,i,n)=>{if(!(r.length===e.length&&e.length===t.length))throw new Error("Number of blobVersionedHashes, blobs, and commitments not all equal");if(r.length===0)throw new Error("Invalid transaction with empty blobs");let o;try{o=n.verifyBlobKzgProofBatch(e,t,s)}catch(a){throw new Error(`KZG verification of blobs fail with error=${a}`)}if(!o)throw new Error("KZG proof cannot be verified from blobs/commitments");for(let a=0;a<r.length;a++){const c=ge(t[a],i);if(!M(c,r[a]))throw new Error(`commitment for blob at index ${a} does not match versionedHash`)}};class F extends x{constructor(e,t={}){var l,f,b;super({...e,type:y.BlobEIP4844},t);const{chainId:s,accessList:i,maxFeePerGas:n,maxPriorityFeePerGas:o,maxFeePerBlobGas:a}=e;if(this.common=this._getCommon(t.common,s),this.chainId=this.common.chainId(),!this.common.isActivatedEIP(1559))throw new Error("EIP-1559 not enabled on Common");if(!this.common.isActivatedEIP(4844))throw new Error("EIP-4844 not enabled on Common");this.activeCapabilities=this.activeCapabilities.concat([1559,2718,2930]);const c=I.getAccessListData(i??[]);if(this.accessList=c.accessList,this.AccessListJSON=c.AccessListJSON,I.verifyAccessList(this.accessList),this.maxFeePerGas=m(u(n)),this.maxPriorityFeePerGas=m(u(o)),this._validateCannotExceedMaxInteger({maxFeePerGas:this.maxFeePerGas,maxPriorityFeePerGas:this.maxPriorityFeePerGas}),x._validateNotArray(e),this.gasLimit*this.maxFeePerGas>_){const g=this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");throw new Error(g)}if(this.maxFeePerGas<this.maxPriorityFeePerGas){const g=this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");throw new Error(g)}this.maxFeePerBlobGas=m(u((a??"")===""?"0x":a)),this.blobVersionedHashes=(e.blobVersionedHashes??[]).map(g=>u(g)),q(this),H(this);for(const g of this.blobVersionedHashes){if(g.length!==32){const P=this._errorMsg("versioned hash is invalid length");throw new Error(P)}if(BigInt(g[0])!==this.common.param("sharding","blobCommitmentVersionKzg")){const P=this._errorMsg("versioned hash does not start with KZG commitment version");throw new Error(P)}}if(this.blobVersionedHashes.length>ue){const g=this._errorMsg(`tx can contain at most ${ue} blobs`);throw new Error(g)}else if(this.blobVersionedHashes.length===0){const g=this._errorMsg("tx should contain at least one blob");throw new Error(g)}if(this.to===void 0){const g=this._errorMsg('tx should have a "to" field and cannot be used to create contracts');throw new Error(g)}this.blobs=(l=e.blobs)==null?void 0:l.map(g=>u(g)),this.kzgCommitments=(f=e.kzgCommitments)==null?void 0:f.map(g=>u(g)),this.kzgProofs=(b=e.kzgProofs)==null?void 0:b.map(g=>u(g)),((t==null?void 0:t.freeze)??!0)&&Object.freeze(this)}static fromTxData(e,t){var i,n;if(((n=(i=t==null?void 0:t.common)==null?void 0:i.customCrypto)==null?void 0:n.kzg)===void 0)throw new Error("A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx");const s=t.common.customCrypto.kzg;if(e.blobsData!==void 0){if(e.blobs!==void 0)throw new Error("cannot have both raw blobs data and encoded blobs in constructor");if(e.kzgCommitments!==void 0)throw new Error("cannot have both raw blobs data and KZG commitments in constructor");if(e.blobVersionedHashes!==void 0)throw new Error("cannot have both raw blobs data and versioned hashes in constructor");if(e.kzgProofs!==void 0)throw new Error("cannot have both raw blobs data and KZG proofs in constructor");e.blobs=Ue(e.blobsData.reduce((o,a)=>o+a)),e.kzgCommitments=Je(s,e.blobs),e.blobVersionedHashes=He(e.kzgCommitments),e.kzgProofs=Ve(s,e.blobs,e.kzgCommitments)}return new F(e,t)}getEffectivePriorityFee(e){return re(this,e)}static minimalFromNetworkWrapper(e,t){var i,n;if(((n=(i=t==null?void 0:t.common)==null?void 0:i.customCrypto)==null?void 0:n.kzg)===void 0)throw new Error("A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx");return F.fromTxData({...e,blobs:void 0,kzgCommitments:void 0,kzgProofs:void 0},t)}static fromSerializedTx(e,t={}){var i,n;if(((n=(i=t.common)==null?void 0:i.customCrypto)==null?void 0:n.kzg)===void 0)throw new Error("A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx");if(M(e.subarray(0,1),O(y.BlobEIP4844))===!1)throw new Error(`Invalid serialized tx input: not an EIP-4844 transaction (wrong tx type, expected: ${y.BlobEIP4844}, received: ${E(e.subarray(0,1))}`);const s=S.decode(e.subarray(1));if(!Array.isArray(s))throw new Error("Invalid serialized tx input: must be array");return F.fromValuesArray(s,t)}static fromValuesArray(e,t={}){var D,U;if(((U=(D=t.common)==null?void 0:D.customCrypto)==null?void 0:U.kzg)===void 0)throw new Error("A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx");if(e.length!==11&&e.length!==14)throw new Error("Invalid EIP-4844 transaction. Only expecting 11 values (for unsigned tx) or 14 values (for signed tx).");const[s,i,n,o,a,c,d,l,f,b,g,P,v,R]=e;return this._validateNotArray({chainId:s,v:P}),B({nonce:i,maxPriorityFeePerGas:n,maxFeePerGas:o,gasLimit:a,value:d,maxFeePerBlobGas:b,v:P,r:v,s:R}),new F({chainId:m(s),nonce:i,maxPriorityFeePerGas:n,maxFeePerGas:o,gasLimit:a,to:c,value:d,data:l,accessList:f??[],maxFeePerBlobGas:b,blobVersionedHashes:g,v:P!==void 0?m(P):void 0,r:v,s:R},t)}static fromSerializedBlobTxNetworkWrapper(e,t){var f,b;if(!t||!t.common)throw new Error("common instance required to validate versioned hashes");if(((b=(f=t.common)==null?void 0:f.customCrypto)==null?void 0:b.kzg)===void 0)throw new Error("A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx");if(M(e.subarray(0,1),O(y.BlobEIP4844))===!1)throw new Error(`Invalid serialized tx input: not an EIP-4844 transaction (wrong tx type, expected: ${y.BlobEIP4844}, received: ${E(e.subarray(0,1))}`);const s=S.decode(e.subarray(1));if(s.length!==4)throw Error("Expected 4 values in the deserialized network transaction");const[i,n,o,a]=s,c=F.fromValuesArray(i,{...t,freeze:!1});if(c.to===void 0)throw Error("BlobEIP4844Transaction can not be send without a valid `to`");const d=Number(t.common.param("sharding","blobCommitmentVersionKzg"));return st(c.blobVersionedHashes,n,o,a,d,t.common.customCrypto.kzg),c.blobs=n,c.kzgCommitments=o,c.kzgProofs=a,((t==null?void 0:t.freeze)??!0)&&Object.freeze(c),c}getDataFee(){return ne(this)}getUpfrontCost(e=$){return se(this,e)}raw(){return[h(this.chainId),h(this.nonce),h(this.maxPriorityFeePerGas),h(this.maxFeePerGas),h(this.gasLimit),this.to!==void 0?this.to.bytes:new Uint8Array(0),h(this.value),this.data,this.accessList,h(this.maxFeePerBlobGas),this.blobVersionedHashes,this.v!==void 0?h(this.v):new Uint8Array(0),this.r!==void 0?h(this.r):new Uint8Array(0),this.s!==void 0?h(this.s):new Uint8Array(0)]}serialize(){return z(this)}serializeNetworkWrapper(){if(this.blobs===void 0||this.kzgCommitments===void 0||this.kzgProofs===void 0)throw new Error("cannot serialize network wrapper without blobs, KZG commitments and KZG proofs provided");return z(this,[this.raw(),this.blobs,this.kzgCommitments,this.kzgProofs])}getMessageToSign(){return z(this,this.raw().slice(0,11))}getHashedMessageToSign(){return Z(this)}hash(){return V(this)}getMessageToVerifySignature(){return this.getHashedMessageToSign()}getSenderPublicKey(){return K(this)}static networkWrapperToJson(e,t){const s=this.fromSerializedBlobTxNetworkWrapper(e,t),i=I.getAccessListJSON(s.accessList);return{...s.toJSON(),chainId:w(s.chainId),maxPriorityFeePerGas:w(s.maxPriorityFeePerGas),maxFeePerGas:w(s.maxFeePerGas),accessList:i,maxFeePerBlobGas:w(s.maxFeePerBlobGas),blobVersionedHashes:s.blobVersionedHashes.map(o=>E(o)),blobs:s.blobs.map(o=>E(o)),kzgCommitments:s.kzgCommitments.map(o=>E(o)),kzgProofs:s.kzgProofs.map(o=>E(o))}}toJSON(){const e=I.getAccessListJSON(this.accessList);return{...super.toJSON(),chainId:w(this.chainId),maxPriorityFeePerGas:w(this.maxPriorityFeePerGas),maxFeePerGas:w(this.maxFeePerGas),accessList:e,maxFeePerBlobGas:w(this.maxFeePerBlobGas),blobVersionedHashes:this.blobVersionedHashes.map(s=>E(s))}}addSignature(e,t,s,i=!1){t=u(t),s=u(s);const n={...this.txOptions,common:this.common};return F.fromTxData({chainId:this.chainId,nonce:this.nonce,maxPriorityFeePerGas:this.maxPriorityFeePerGas,maxFeePerGas:this.maxFeePerGas,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,accessList:this.accessList,v:i?e-X:e,r:m(t),s:m(s),maxFeePerBlobGas:this.maxFeePerBlobGas,blobVersionedHashes:this.blobVersionedHashes,blobs:this.blobs,kzgCommitments:this.kzgCommitments,kzgProofs:this.kzgProofs},n)}errorStr(){let e=this._getSharedErrorPostfix();return e+=` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`,e}_errorMsg(e){return G(this,e)}numBlobs(){return this.blobVersionedHashes.length}}function rt(r){const e=BigInt(I.getDataFeeEIP2930(r.accessList,r.common)),t=BigInt(r.authorizationList.length*Number(r.common.param("gasPrices","perAuthBaseCost")));return ie(r,e+t)}class N extends x{constructor(e,t={}){super({...e,type:y.EOACodeEIP7702},t);const{chainId:s,accessList:i,authorizationList:n,maxFeePerGas:o,maxPriorityFeePerGas:a}=e;if(this.common=this._getCommon(t.common,s),this.chainId=this.common.chainId(),!this.common.isActivatedEIP(7702))throw new Error("EIP-7702 not enabled on Common");this.activeCapabilities=this.activeCapabilities.concat([1559,2718,2930,7702]);const c=I.getAccessListData(i??[]);this.accessList=c.accessList,this.AccessListJSON=c.AccessListJSON,I.verifyAccessList(this.accessList);const d=de.getAuthorizationListData(n??[]);if(this.authorizationList=d.authorizationList,this.AuthorizationListJSON=d.AuthorizationListJSON,de.verifyAuthorizationList(this.authorizationList),this.maxFeePerGas=m(u(o)),this.maxPriorityFeePerGas=m(u(a)),this._validateCannotExceedMaxInteger({maxFeePerGas:this.maxFeePerGas,maxPriorityFeePerGas:this.maxPriorityFeePerGas}),x._validateNotArray(e),this.gasLimit*this.maxFeePerGas>_){const f=this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");throw new Error(f)}if(this.maxFeePerGas<this.maxPriorityFeePerGas){const f=this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");throw new Error(f)}q(this),H(this),((t==null?void 0:t.freeze)??!0)&&Object.freeze(this)}static fromTxData(e,t={}){return new N(e,t)}static fromSerializedTx(e,t={}){if(M(e.subarray(0,1),O(y.EOACodeEIP7702))===!1)throw new Error(`Invalid serialized tx input: not an EIP-7702 transaction (wrong tx type, expected: ${y.EOACodeEIP7702}, received: ${E(e.subarray(0,1))}`);const s=S.decode(e.subarray(1));if(!Array.isArray(s))throw new Error("Invalid serialized tx input: must be array");return N.fromValuesArray(s,t)}static fromValuesArray(e,t={}){if(e.length!==10&&e.length!==13)throw new Error("Invalid EIP-7702 transaction. Only expecting 10 values (for unsigned tx) or 13 values (for signed tx).");const[s,i,n,o,a,c,d,l,f,b,g,P,v]=e;return this._validateNotArray({chainId:s,v:g}),B({nonce:i,maxPriorityFeePerGas:n,maxFeePerGas:o,gasLimit:a,value:d,v:g,r:P,s:v}),new N({chainId:m(s),nonce:i,maxPriorityFeePerGas:n,maxFeePerGas:o,gasLimit:a,to:c,value:d,data:l,accessList:f??[],authorizationList:b??[],v:g!==void 0?m(g):void 0,r:P,s:v},t)}getDataFee(){return rt(this)}getEffectivePriorityFee(e){return re(this,e)}getUpfrontCost(e=$){return se(this,e)}raw(){return[h(this.chainId),h(this.nonce),h(this.maxPriorityFeePerGas),h(this.maxFeePerGas),h(this.gasLimit),this.to!==void 0?this.to.bytes:new Uint8Array(0),h(this.value),this.data,this.accessList,this.authorizationList,this.v!==void 0?h(this.v):new Uint8Array(0),this.r!==void 0?h(this.r):new Uint8Array(0),this.s!==void 0?h(this.s):new Uint8Array(0)]}serialize(){return z(this)}getMessageToSign(){return z(this,this.raw().slice(0,10))}getHashedMessageToSign(){return Z(this)}hash(){return V(this)}getMessageToVerifySignature(){return this.getHashedMessageToSign()}getSenderPublicKey(){return K(this)}addSignature(e,t,s,i=!1){t=u(t),s=u(s);const n={...this.txOptions,common:this.common};return N.fromTxData({chainId:this.chainId,nonce:this.nonce,maxPriorityFeePerGas:this.maxPriorityFeePerGas,maxFeePerGas:this.maxFeePerGas,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,accessList:this.accessList,authorizationList:this.authorizationList,v:i?e-X:e,r:m(t),s:m(s)},n)}toJSON(){const e=I.getAccessListJSON(this.accessList);return{...super.toJSON(),chainId:w(this.chainId),maxPriorityFeePerGas:w(this.maxPriorityFeePerGas),maxFeePerGas:w(this.maxFeePerGas),accessList:e,authorizationList:this.AuthorizationListJSON}}errorStr(){let e=this._getSharedErrorPostfix();return e+=` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`,e}_errorMsg(e){return G(this,e)}}function me(r,e){const t=Number(r),s=Number(e)*2;return t===s+35||t===s+36}class C extends x{constructor(e,t={}){if(super({...e,type:y.Legacy},t),this.common=this._validateTxV(this.v,t.common),this.keccakFunction=this.common.customCrypto.keccak256??ee,this.gasPrice=m(u(e.gasPrice)),this.gasPrice*this.gasLimit>_){const i=this._errorMsg("gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)");throw new Error(i)}this._validateCannotExceedMaxInteger({gasPrice:this.gasPrice}),x._validateNotArray(e),this.common.gteHardfork("spuriousDragon")&&(this.isSigned()?me(this.v,this.common.chainId())&&this.activeCapabilities.push(A.EIP155ReplayProtection):this.activeCapabilities.push(A.EIP155ReplayProtection)),((t==null?void 0:t.freeze)??!0)&&Object.freeze(this)}static fromTxData(e,t={}){return new C(e,t)}static fromSerializedTx(e,t={}){const s=S.decode(e);if(!Array.isArray(s))throw new Error("Invalid serialized tx input. Must be array");return this.fromValuesArray(s,t)}static fromValuesArray(e,t={}){if(e.length!==6&&e.length!==9)throw new Error("Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).");const[s,i,n,o,a,c,d,l,f]=e;return B({nonce:s,gasPrice:i,gasLimit:n,value:a,v:d,r:l,s:f}),new C({nonce:s,gasPrice:i,gasLimit:n,to:o,value:a,data:c,v:d,r:l,s:f},t)}getEffectivePriorityFee(e){return le(this.gasPrice,e)}raw(){return[h(this.nonce),h(this.gasPrice),h(this.gasLimit),this.to!==void 0?this.to.bytes:new Uint8Array(0),h(this.value),this.data,this.v!==void 0?h(this.v):new Uint8Array(0),this.r!==void 0?h(this.r):new Uint8Array(0),this.s!==void 0?h(this.s):new Uint8Array(0)]}serialize(){return S.encode(this.raw())}getMessageToSign(){const e=[h(this.nonce),h(this.gasPrice),h(this.gasLimit),this.to!==void 0?this.to.bytes:new Uint8Array(0),h(this.value),this.data];return this.supports(A.EIP155ReplayProtection)&&(e.push(h(this.common.chainId())),e.push(Y(u(0))),e.push(Y(u(0)))),e}getHashedMessageToSign(){const e=this.getMessageToSign();return this.keccakFunction(S.encode(e))}getDataFee(){return ie(this)}getUpfrontCost(){return this.gasLimit*this.gasPrice+this.value}hash(){return V(this)}getMessageToVerifySignature(){if(!this.isSigned()){const e=this._errorMsg("This transaction is not signed");throw new Error(e)}return this.getHashedMessageToSign()}getSenderPublicKey(){return K(this)}addSignature(e,t,s,i=!1){t=u(t),s=u(s),i&&this.supports(A.EIP155ReplayProtection)&&(e+=this.common.chainId()*ae+Ce);const n={...this.txOptions,common:this.common};return C.fromTxData({nonce:this.nonce,gasPrice:this.gasPrice,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,v:e,r:m(t),s:m(s)},n)}toJSON(){return{...super.toJSON(),gasPrice:w(this.gasPrice)}}_validateTxV(e,t){let s;const i=e!==void 0?Number(e):void 0;if(i!==void 0&&i<37&&i!==27&&i!==28)throw new Error(`Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ${i}`);if(i!==void 0&&i!==0&&(!t||t.gteHardfork("spuriousDragon"))&&i!==27&&i!==28)if(t){if(!me(BigInt(i),t.chainId()))throw new Error(`Incompatible EIP155-based V ${i} and chain id ${t.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`)}else{let n;(i-35)%2===0?n=35:n=36,s=BigInt(i-n)/ae}return this._getCommon(t,s)}errorStr(){let e=this._getSharedErrorPostfix();return e+=` gasPrice=${this.gasPrice}`,e}_errorMsg(e){return G(this,e)}}const it=r=>{const e=Object.assign({},r);return e.gasLimit=ce(e.gasLimit??e.gas,he.BigInt),e.data=e.data===void 0?e.input:e.data,e.gasPrice=e.gasPrice!==void 0?BigInt(e.gasPrice):void 0,e.value=e.value!==void 0?BigInt(e.value):void 0,e.to=e.to!==null&&e.to!==void 0?W(u(e.to),20):null,e.v=e.v==="0x0"?"0x":e.v,e.r=e.r==="0x0"?"0x":e.r,e.s=e.s==="0x0"?"0x":e.s,(e.v!=="0x"||e.r!=="0x"||e.s!=="0x")&&(e.v=ce(e.v,he.BigInt)),e};class Q{constructor(){}static fromTxData(e,t={}){if(!("type"in e)||e.type===void 0)return C.fromTxData(e,t);if(qe(e))return C.fromTxData(e,t);if(We(e))return k.fromTxData(e,t);if(Ye(e))return T.fromTxData(e,t);if(Qe(e))return F.fromTxData(e,t);if(et(e))return N.fromTxData(e,t);throw new Error(`Tx instantiation with type ${e==null?void 0:e.type} not supported`)}static fromSerializedData(e,t={}){if(e[0]<=127)switch(e[0]){case y.AccessListEIP2930:return k.fromSerializedTx(e,t);case y.FeeMarketEIP1559:return T.fromSerializedTx(e,t);case y.BlobEIP4844:return F.fromSerializedTx(e,t);case y.EOACodeEIP7702:return N.fromSerializedTx(e,t);default:throw new Error(`TypedTransaction with ID ${e[0]} unknown`)}else return C.fromSerializedTx(e,t)}static fromBlockBodyData(e,t={}){if(e instanceof Uint8Array)return this.fromSerializedData(e,t);if(Array.isArray(e))return C.fromValuesArray(e,t);throw new Error("Cannot decode transaction: unknown type input")}static async fromJsonRpcProvider(e,t,s){const i=Re(e),n=await Ke(i,{method:"eth_getTransactionByHash",params:[t]});if(n===null)throw new Error("No data returned from provider");return Q.fromRPC(n,s)}static async fromRPC(e,t={}){return Q.fromTxData(it(e),t)}}export{k as AccessListEIP2930Transaction,F as BlobEIP4844Transaction,A as Capability,N as EOACodeEIP7702Transaction,T as FeeMarketEIP1559Transaction,C as LegacyTransaction,Q as TransactionFactory,y as TransactionType,je as isAccessList,De as isAccessListBytes,We as isAccessListEIP2930TxData,Ze as isAuthorizationList,Xe as isAuthorizationListBytes,Qe as isBlobEIP4844TxData,et as isEOACodeEIP7702TxData,Ye as isFeeMarketEIP1559TxData,qe as isLegacyTxData};
